function fontString(pixelSize,fontStyle,fontFamily){return fontStyle+" "+pixelSize+"px "+fontFamily}const requestAnimFrame=function(){if(typeof window==="undefined"){return function(callback){return callback()}}return window.requestAnimationFrame}();function throttled(fn,thisArg,updateFn){const updateArgs=updateFn||(args=>Array.prototype.slice.call(args));let ticking=false;let args=[];return function(...rest){args=updateArgs(rest);if(!ticking){ticking=true;requestAnimFrame.call(window,()=>{ticking=false;fn.apply(thisArg,args)})}}}function debounce(fn,delay){let timeout;return function(){if(delay){clearTimeout(timeout);timeout=setTimeout(fn,delay)}else{fn()}return delay}}const _toLeftRightCenter=align=>align==="start"?"left":align==="end"?"right":"center";const _alignStartEnd=(align,start,end)=>align==="start"?start:align==="end"?end:(start+end)/2;function noop(){}const uid=function(){let id=0;return function(){return id++}}();function isNullOrUndef(value){return value===null||typeof value==="undefined"}function isArray(value){if(Array.isArray&&Array.isArray(value)){return true}const type=Object.prototype.toString.call(value);if(type.substr(0,7)==="[object"&&type.substr(-6)==="Array]"){return true}return false}function isObject(value){return value!==null&&Object.prototype.toString.call(value)==="[object Object]"}const isNumberFinite=value=>(typeof value==="number"||value instanceof Number)&&isFinite(+value);function finiteOrDefault(value,defaultValue){return isNumberFinite(value)?value:defaultValue}function valueOrDefault(value,defaultValue){return typeof value==="undefined"?defaultValue:value}const toPercentage=(value,dimension)=>typeof value==="string"&&value.endsWith("%")?parseFloat(value)/100:value/dimension;const toPixels=(value,dimension)=>typeof value==="string"&&value.endsWith("%")?parseFloat(value)/100*dimension:+value;function callback(fn,args,thisArg){if(fn&&typeof fn.call==="function"){return fn.apply(thisArg,args)}}function each(loopable,fn,thisArg,reverse){let i,len,keys;if(isArray(loopable)){len=loopable.length;if(reverse){for(i=len-1;i>=0;i--){fn.call(thisArg,loopable[i],i)}}else{for(i=0;i<len;i++){fn.call(thisArg,loopable[i],i)}}}else if(isObject(loopable)){keys=Object.keys(loopable);len=keys.length;for(i=0;i<len;i++){fn.call(thisArg,loopable[keys[i]],keys[i])}}}function _elementsEqual(a0,a1){let i,ilen,v0,v1;if(!a0||!a1||a0.length!==a1.length){return false}for(i=0,ilen=a0.length;i<ilen;++i){v0=a0[i];v1=a1[i];if(v0.datasetIndex!==v1.datasetIndex||v0.index!==v1.index){return false}}return true}function clone(source){if(isArray(source)){return source.map(clone)}if(isObject(source)){const target=Object.create(null);const keys=Object.keys(source);const klen=keys.length;let k=0;for(;k<klen;++k){target[keys[k]]=clone(source[keys[k]])}return target}return source}function isValidKey(key){return["__proto__","prototype","constructor"].indexOf(key)===-1}function _merger(key,target,source,options){if(!isValidKey(key)){return}const tval=target[key];const sval=source[key];if(isObject(tval)&&isObject(sval)){merge(tval,sval,options)}else{target[key]=clone(sval)}}function merge(target,source,options){const sources=isArray(source)?source:[source];const ilen=sources.length;if(!isObject(target)){return target}options=options||{};const merger=options.merger||_merger;for(let i=0;i<ilen;++i){source=sources[i];if(!isObject(source)){continue}const keys=Object.keys(source);for(let k=0,klen=keys.length;k<klen;++k){merger(keys[k],target,source,options)}}return target}function mergeIf(target,source){return merge(target,source,{merger:_mergerIf})}function _mergerIf(key,target,source){if(!isValidKey(key)){return}const tval=target[key];const sval=source[key];if(isObject(tval)&&isObject(sval)){mergeIf(tval,sval)}else if(!Object.prototype.hasOwnProperty.call(target,key)){target[key]=clone(sval)}}function _deprecated(scope,value,previous,current){if(value!==undefined){console.warn(scope+': "'+previous+'" is deprecated. Please use "'+current+'" instead')}}const emptyString="";const dot=".";function indexOfDotOrLength(key,start){const idx=key.indexOf(dot,start);return idx===-1?key.length:idx}function resolveObjectKey(obj,key){if(key===emptyString){return obj}let pos=0;let idx=indexOfDotOrLength(key,pos);while(idx>pos){obj=obj[key.substr(pos,idx-pos)];if(!obj){break}pos=idx+1;idx=indexOfDotOrLength(key,pos)}return obj}function _capitalize(str){return str.charAt(0).toUpperCase()+str.slice(1)}const defined=value=>typeof value!=="undefined";const isFunction=value=>typeof value==="function";const PI=Math.PI;const TAU=2*PI;const PITAU=TAU+PI;const INFINITY=Number.POSITIVE_INFINITY;const RAD_PER_DEG=PI/180;const HALF_PI=PI/2;const QUARTER_PI=PI/4;const TWO_THIRDS_PI=PI*2/3;function _factorize(value){const result=[];const sqrt=Math.sqrt(value);let i;for(i=1;i<sqrt;i++){if(value%i===0){result.push(i);result.push(value/i)}}if(sqrt===(sqrt|0)){result.push(sqrt)}result.sort((a,b)=>a-b).pop();return result}const log10=Math.log10||function(x){const exponent=Math.log(x)*Math.LOG10E;const powerOf10=Math.round(exponent);const isPowerOf10=x===Math.pow(10,powerOf10);return isPowerOf10?powerOf10:exponent};function isNumber(n){return!isNaN(parseFloat(n))&&isFinite(n)}function almostEquals(x,y,epsilon){return Math.abs(x-y)<epsilon}function almostWhole(x,epsilon){const rounded=Math.round(x);return rounded-epsilon<=x&&rounded+epsilon>=x}function _setMinAndMaxByKey(array,target,property){let i,ilen,value;for(i=0,ilen=array.length;i<ilen;i++){value=array[i][property];if(!isNaN(value)){target.min=Math.min(target.min,value);target.max=Math.max(target.max,value)}}}const sign=Math.sign?function(x){return Math.sign(x)}:function(x){x=+x;if(x===0||isNaN(x)){return x}return x>0?1:-1};function toRadians(degrees){return degrees*(PI/180)}function toDegrees(radians){return radians*(180/PI)}function _decimalPlaces(x){if(!isNumberFinite(x)){return}let e=1;let p=0;while(Math.round(x*e)/e!==x){e*=10;p++}return p}function getAngleFromPoint(centrePoint,anglePoint){const distanceFromXCenter=anglePoint.x-centrePoint.x;const distanceFromYCenter=anglePoint.y-centrePoint.y;const radialDistanceFromCenter=Math.sqrt(distanceFromXCenter*distanceFromXCenter+distanceFromYCenter*distanceFromYCenter);let angle=Math.atan2(distanceFromYCenter,distanceFromXCenter);if(angle<-.5*PI){angle+=TAU}return{angle:angle,distance:radialDistanceFromCenter}}function distanceBetweenPoints(pt1,pt2){return Math.sqrt(Math.pow(pt2.x-pt1.x,2)+Math.pow(pt2.y-pt1.y,2))}function _angleDiff(a,b){return(a-b+PITAU)%TAU-PI}function _normalizeAngle(a){return(a%TAU+TAU)%TAU}function _angleBetween(angle,start,end){const a=_normalizeAngle(angle);const s=_normalizeAngle(start);const e=_normalizeAngle(end);const angleToStart=_normalizeAngle(s-a);const angleToEnd=_normalizeAngle(e-a);const startToAngle=_normalizeAngle(a-s);const endToAngle=_normalizeAngle(a-e);return a===s||a===e||angleToStart>angleToEnd&&startToAngle<endToAngle}function _limitValue(value,min,max){return Math.max(min,Math.min(max,value))}function _int16Range(value){return _limitValue(value,-32768,32767)}const atEdge=t=>t===0||t===1;const elasticIn=(t,s,p)=>-(Math.pow(2,10*(t-=1))*Math.sin((t-s)*TAU/p));const elasticOut=(t,s,p)=>Math.pow(2,-10*t)*Math.sin((t-s)*TAU/p)+1;const effects={linear:t=>t,easeInQuad:t=>t*t,easeOutQuad:t=>-t*(t-2),easeInOutQuad:t=>(t/=.5)<1?.5*t*t:-.5*(--t*(t-2)-1),easeInCubic:t=>t*t*t,easeOutCubic:t=>(t-=1)*t*t+1,easeInOutCubic:t=>(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2),easeInQuart:t=>t*t*t*t,easeOutQuart:t=>-((t-=1)*t*t*t-1),easeInOutQuart:t=>(t/=.5)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2),easeInQuint:t=>t*t*t*t*t,easeOutQuint:t=>(t-=1)*t*t*t*t+1,easeInOutQuint:t=>(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2),easeInSine:t=>-Math.cos(t*HALF_PI)+1,easeOutSine:t=>Math.sin(t*HALF_PI),easeInOutSine:t=>-.5*(Math.cos(PI*t)-1),easeInExpo:t=>t===0?0:Math.pow(2,10*(t-1)),easeOutExpo:t=>t===1?1:-Math.pow(2,-10*t)+1,easeInOutExpo:t=>atEdge(t)?t:t<.5?.5*Math.pow(2,10*(t*2-1)):.5*(-Math.pow(2,-10*(t*2-1))+2),easeInCirc:t=>t>=1?t:-(Math.sqrt(1-t*t)-1),easeOutCirc:t=>Math.sqrt(1-(t-=1)*t),easeInOutCirc:t=>(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1),easeInElastic:t=>atEdge(t)?t:elasticIn(t,.075,.3),easeOutElastic:t=>atEdge(t)?t:elasticOut(t,.075,.3),easeInOutElastic(t){const s=.1125;const p=.45;return atEdge(t)?t:t<.5?.5*elasticIn(t*2,s,p):.5+.5*elasticOut(t*2-1,s,p)},easeInBack(t){const s=1.70158;return t*t*((s+1)*t-s)},easeOutBack(t){const s=1.70158;return(t-=1)*t*((s+1)*t+s)+1},easeInOutBack(t){let s=1.70158;if((t/=.5)<1){return.5*(t*t*(((s*=1.525)+1)*t-s))}return.5*((t-=2)*t*(((s*=1.525)+1)*t+s)+2)},easeInBounce:t=>1-effects.easeOutBounce(1-t),easeOutBounce(t){const m=7.5625;const d=2.75;if(t<1/d){return m*t*t}if(t<2/d){return m*(t-=1.5/d)*t+.75}if(t<2.5/d){return m*(t-=2.25/d)*t+.9375}return m*(t-=2.625/d)*t+.984375},easeInOutBounce:t=>t<.5?effects.easeInBounce(t*2)*.5:effects.easeOutBounce(t*2-1)*.5+.5};const map={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15};const hex="0123456789ABCDEF";const h1=b=>hex[b&15];const h2=b=>hex[(b&240)>>4]+hex[b&15];const eq=b=>(b&240)>>4===(b&15);function isShort(v){return eq(v.r)&&eq(v.g)&&eq(v.b)&&eq(v.a)}function hexParse(str){var len=str.length;var ret;if(str[0]==="#"){if(len===4||len===5){ret={r:255&map[str[1]]*17,g:255&map[str[2]]*17,b:255&map[str[3]]*17,a:len===5?map[str[4]]*17:255}}else if(len===7||len===9){ret={r:map[str[1]]<<4|map[str[2]],g:map[str[3]]<<4|map[str[4]],b:map[str[5]]<<4|map[str[6]],a:len===9?map[str[7]]<<4|map[str[8]]:255}}}return ret}function hexString(v){var f=isShort(v)?h1:h2;return v?"#"+f(v.r)+f(v.g)+f(v.b)+(v.a<255?f(v.a):""):v}function round(v){return v+.5|0}const lim=(v,l,h)=>Math.max(Math.min(v,h),l);function p2b(v){return lim(round(v*2.55),0,255)}function n2b(v){return lim(round(v*255),0,255)}function b2n(v){return lim(round(v/2.55)/100,0,1)}function n2p(v){return lim(round(v*100),0,100)}const RGB_RE=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;function rgbParse(str){const m=RGB_RE.exec(str);let a=255;let r,g,b;if(!m){return}if(m[7]!==r){const v=+m[7];a=255&(m[8]?p2b(v):v*255)}r=+m[1];g=+m[3];b=+m[5];r=255&(m[2]?p2b(r):r);g=255&(m[4]?p2b(g):g);b=255&(m[6]?p2b(b):b);return{r:r,g:g,b:b,a:a}}function rgbString(v){return v&&(v.a<255?`rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`:`rgb(${v.r}, ${v.g}, ${v.b})`)}const HUE_RE=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function hsl2rgbn(h,s,l){const a=s*Math.min(l,1-l);const f=(n,k=(n+h/30)%12)=>l-a*Math.max(Math.min(k-3,9-k,1),-1);return[f(0),f(8),f(4)]}function hsv2rgbn(h,s,v){const f=(n,k=(n+h/60)%6)=>v-v*s*Math.max(Math.min(k,4-k,1),0);return[f(5),f(3),f(1)]}function hwb2rgbn(h,w,b){const rgb=hsl2rgbn(h,1,.5);let i;if(w+b>1){i=1/(w+b);w*=i;b*=i}for(i=0;i<3;i++){rgb[i]*=1-w-b;rgb[i]+=w}return rgb}function rgb2hsl(v){const range=255;const r=v.r/range;const g=v.g/range;const b=v.b/range;const max=Math.max(r,g,b);const min=Math.min(r,g,b);const l=(max+min)/2;let h,s,d;if(max!==min){d=max-min;s=l>.5?d/(2-max-min):d/(max+min);h=max===r?(g-b)/d+(g<b?6:0):max===g?(b-r)/d+2:(r-g)/d+4;h=h*60+.5}return[h|0,s||0,l]}function calln(f,a,b,c){return(Array.isArray(a)?f(a[0],a[1],a[2]):f(a,b,c)).map(n2b)}function hsl2rgb(h,s,l){return calln(hsl2rgbn,h,s,l)}function hwb2rgb(h,w,b){return calln(hwb2rgbn,h,w,b)}function hsv2rgb(h,s,v){return calln(hsv2rgbn,h,s,v)}function hue(h){return(h%360+360)%360}function hueParse(str){const m=HUE_RE.exec(str);let a=255;let v;if(!m){return}if(m[5]!==v){a=m[6]?p2b(+m[5]):n2b(+m[5])}const h=hue(+m[2]);const p1=+m[3]/100;const p2=+m[4]/100;if(m[1]==="hwb"){v=hwb2rgb(h,p1,p2)}else if(m[1]==="hsv"){v=hsv2rgb(h,p1,p2)}else{v=hsl2rgb(h,p1,p2)}return{r:v[0],g:v[1],b:v[2],a:a}}function rotate(v,deg){var h=rgb2hsl(v);h[0]=hue(h[0]+deg);h=hsl2rgb(h);v.r=h[0];v.g=h[1];v.b=h[2]}function hslString(v){if(!v){return}const a=rgb2hsl(v);const h=a[0];const s=n2p(a[1]);const l=n2p(a[2]);return v.a<255?`hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`:`hsl(${h}, ${s}%, ${l}%)`}const map$1={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"};const names={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};function unpack(){const unpacked={};const keys=Object.keys(names);const tkeys=Object.keys(map$1);let i,j,k,ok,nk;for(i=0;i<keys.length;i++){ok=nk=keys[i];for(j=0;j<tkeys.length;j++){k=tkeys[j];nk=nk.replace(k,map$1[k])}k=parseInt(names[ok],16);unpacked[nk]=[k>>16&255,k>>8&255,k&255]}return unpacked}let names$1;function nameParse(str){if(!names$1){names$1=unpack();names$1.transparent=[0,0,0,0]}const a=names$1[str.toLowerCase()];return a&&{r:a[0],g:a[1],b:a[2],a:a.length===4?a[3]:255}}function modHSL(v,i,ratio){if(v){let tmp=rgb2hsl(v);tmp[i]=Math.max(0,Math.min(tmp[i]+tmp[i]*ratio,i===0?360:1));tmp=hsl2rgb(tmp);v.r=tmp[0];v.g=tmp[1];v.b=tmp[2]}}function clone$1(v,proto){return v?Object.assign(proto||{},v):v}function fromObject(input){var v={r:0,g:0,b:0,a:255};if(Array.isArray(input)){if(input.length>=3){v={r:input[0],g:input[1],b:input[2],a:255};if(input.length>3){v.a=n2b(input[3])}}}else{v=clone$1(input,{r:0,g:0,b:0,a:1});v.a=n2b(v.a)}return v}function functionParse(str){if(str.charAt(0)==="r"){return rgbParse(str)}return hueParse(str)}class Color{constructor(input){if(input instanceof Color){return input}const type=typeof input;let v;if(type==="object"){v=fromObject(input)}else if(type==="string"){v=hexParse(input)||nameParse(input)||functionParse(input)}this._rgb=v;this._valid=!!v}get valid(){return this._valid}get rgb(){var v=clone$1(this._rgb);if(v){v.a=b2n(v.a)}return v}set rgb(obj){this._rgb=fromObject(obj)}rgbString(){return this._valid?rgbString(this._rgb):this._rgb}hexString(){return this._valid?hexString(this._rgb):this._rgb}hslString(){return this._valid?hslString(this._rgb):this._rgb}mix(color,weight){const me=this;if(color){const c1=me.rgb;const c2=color.rgb;let w2;const p=weight===w2?.5:weight;const w=2*p-1;const a=c1.a-c2.a;const w1=((w*a===-1?w:(w+a)/(1+w*a))+1)/2;w2=1-w1;c1.r=255&w1*c1.r+w2*c2.r+.5;c1.g=255&w1*c1.g+w2*c2.g+.5;c1.b=255&w1*c1.b+w2*c2.b+.5;c1.a=p*c1.a+(1-p)*c2.a;me.rgb=c1}return me}clone(){return new Color(this.rgb)}alpha(a){this._rgb.a=n2b(a);return this}clearer(ratio){const rgb=this._rgb;rgb.a*=1-ratio;return this}greyscale(){const rgb=this._rgb;const val=round(rgb.r*.3+rgb.g*.59+rgb.b*.11);rgb.r=rgb.g=rgb.b=val;return this}opaquer(ratio){const rgb=this._rgb;rgb.a*=1+ratio;return this}negate(){const v=this._rgb;v.r=255-v.r;v.g=255-v.g;v.b=255-v.b;return this}lighten(ratio){modHSL(this._rgb,2,ratio);return this}darken(ratio){modHSL(this._rgb,2,-ratio);return this}saturate(ratio){modHSL(this._rgb,1,ratio);return this}desaturate(ratio){modHSL(this._rgb,1,-ratio);return this}rotate(deg){rotate(this._rgb,deg);return this}}function index_esm(input){return new Color(input)}const isPatternOrGradient=value=>value instanceof CanvasGradient||value instanceof CanvasPattern;function color(value){return isPatternOrGradient(value)?value:index_esm(value)}function getHoverColor(value){return isPatternOrGradient(value)?value:index_esm(value).saturate(.5).darken(.1).hexString()}const privateSymbol=Symbol("private");function getScope(node,key){if(!key){return node}const keys=key.split(".");for(let i=0,n=keys.length;i<n;++i){const k=keys[i];node=node[k]||(node[k]=Object.create(null))}return node}class Defaults{constructor(descriptors){this.animation=undefined;this.backgroundColor="rgba(0,0,0,0.1)";this.borderColor="rgba(0,0,0,0.1)";this.color="#666";this.controllers={};this.devicePixelRatio=context=>context.chart.platform.getDevicePixelRatio();this.elements={};this.events=["mousemove","mouseout","click","touchstart","touchmove"];this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null};this.hover={onHover:null};this.hoverBackgroundColor=(ctx,options)=>getHoverColor(options.backgroundColor);this.hoverBorderColor=(ctx,options)=>getHoverColor(options.borderColor);this.hoverColor=(ctx,options)=>getHoverColor(options.color);this.indexAxis="x";this.interaction={mode:"nearest",intersect:true};this.maintainAspectRatio=true;this.onHover=null;this.onClick=null;this.parsing=true;this.plugins={};this.responsive=true;this.scale=undefined;this.scales={};this.showLine=true;Object.defineProperty(this,privateSymbol,{value:Object.create(null),writable:false});this.describe(descriptors)}set(scope,values){if(typeof scope==="string"){return merge(getScope(this,scope),values)}return merge(getScope(this,""),scope)}get(scope){return getScope(this,scope)}describe(scope,values){const root=this[privateSymbol];if(typeof scope==="string"){return merge(getScope(root,scope),values)}return merge(getScope(root,""),scope)}get descriptors(){return this[privateSymbol]}route(scope,name,targetScope,targetName){const scopeObject=getScope(this,scope);const targetScopeObject=getScope(this,targetScope);const privateName="_"+name;Object.defineProperties(scopeObject,{[privateName]:{value:scopeObject[name],writable:true},[name]:{enumerable:true,get(){const local=this[privateName];const target=targetScopeObject[targetName];if(isObject(local)){return Object.assign({},target,local)}return valueOrDefault(local,target)},set(value){this[privateName]=value}}})}}var defaults=new Defaults({_scriptable:name=>!name.startsWith("on"),_indexable:name=>name!=="events",hover:{_fallback:"interaction"},interaction:{_scriptable:false,_indexable:false}});function toFontString(font){if(!font||isNullOrUndef(font.size)||isNullOrUndef(font.family)){return null}return(font.style?font.style+" ":"")+(font.weight?font.weight+" ":"")+font.size+"px "+font.family}function _measureText(ctx,data,gc,longest,string){let textWidth=data[string];if(!textWidth){textWidth=data[string]=ctx.measureText(string).width;gc.push(string)}if(textWidth>longest){longest=textWidth}return longest}function _longestText(ctx,font,arrayOfThings,cache){cache=cache||{};let data=cache.data=cache.data||{};let gc=cache.garbageCollect=cache.garbageCollect||[];if(cache.font!==font){data=cache.data={};gc=cache.garbageCollect=[];cache.font=font}ctx.save();ctx.font=font;let longest=0;const ilen=arrayOfThings.length;let i,j,jlen,thing,nestedThing;for(i=0;i<ilen;i++){thing=arrayOfThings[i];if(thing!==undefined&&thing!==null&&isArray(thing)!==true){longest=_measureText(ctx,data,gc,longest,thing)}else if(isArray(thing)){for(j=0,jlen=thing.length;j<jlen;j++){nestedThing=thing[j];if(nestedThing!==undefined&&nestedThing!==null&&!isArray(nestedThing)){longest=_measureText(ctx,data,gc,longest,nestedThing)}}}}ctx.restore();const gcLen=gc.length/2;if(gcLen>arrayOfThings.length){for(i=0;i<gcLen;i++){delete data[gc[i]]}gc.splice(0,gcLen)}return longest}function _alignPixel(chart,pixel,width){const devicePixelRatio=chart.currentDevicePixelRatio;const halfWidth=width/2;return Math.round((pixel-halfWidth)*devicePixelRatio)/devicePixelRatio+halfWidth}function clearCanvas(canvas,ctx){ctx=ctx||canvas.getContext("2d");ctx.save();ctx.resetTransform();ctx.clearRect(0,0,canvas.width,canvas.height);ctx.restore()}function drawPoint(ctx,options,x,y){let type,xOffset,yOffset,size,cornerRadius;const style=options.pointStyle;const rotation=options.rotation;const radius=options.radius;let rad=(rotation||0)*RAD_PER_DEG;if(style&&typeof style==="object"){type=style.toString();if(type==="[object HTMLImageElement]"||type==="[object HTMLCanvasElement]"){ctx.save();ctx.translate(x,y);ctx.rotate(rad);ctx.drawImage(style,-style.width/2,-style.height/2,style.width,style.height);ctx.restore();return}}if(isNaN(radius)||radius<=0){return}ctx.beginPath();switch(style){default:ctx.arc(x,y,radius,0,TAU);ctx.closePath();break;case"triangle":ctx.moveTo(x+Math.sin(rad)*radius,y-Math.cos(rad)*radius);rad+=TWO_THIRDS_PI;ctx.lineTo(x+Math.sin(rad)*radius,y-Math.cos(rad)*radius);rad+=TWO_THIRDS_PI;ctx.lineTo(x+Math.sin(rad)*radius,y-Math.cos(rad)*radius);ctx.closePath();break;case"rectRounded":cornerRadius=radius*.516;size=radius-cornerRadius;xOffset=Math.cos(rad+QUARTER_PI)*size;yOffset=Math.sin(rad+QUARTER_PI)*size;ctx.arc(x-xOffset,y-yOffset,cornerRadius,rad-PI,rad-HALF_PI);ctx.arc(x+yOffset,y-xOffset,cornerRadius,rad-HALF_PI,rad);ctx.arc(x+xOffset,y+yOffset,cornerRadius,rad,rad+HALF_PI);ctx.arc(x-yOffset,y+xOffset,cornerRadius,rad+HALF_PI,rad+PI);ctx.closePath();break;case"rect":if(!rotation){size=Math.SQRT1_2*radius;ctx.rect(x-size,y-size,2*size,2*size);break}rad+=QUARTER_PI;case"rectRot":xOffset=Math.cos(rad)*radius;yOffset=Math.sin(rad)*radius;ctx.moveTo(x-xOffset,y-yOffset);ctx.lineTo(x+yOffset,y-xOffset);ctx.lineTo(x+xOffset,y+yOffset);ctx.lineTo(x-yOffset,y+xOffset);ctx.closePath();break;case"crossRot":rad+=QUARTER_PI;case"cross":xOffset=Math.cos(rad)*radius;yOffset=Math.sin(rad)*radius;ctx.moveTo(x-xOffset,y-yOffset);ctx.lineTo(x+xOffset,y+yOffset);ctx.moveTo(x+yOffset,y-xOffset);ctx.lineTo(x-yOffset,y+xOffset);break;case"star":xOffset=Math.cos(rad)*radius;yOffset=Math.sin(rad)*radius;ctx.moveTo(x-xOffset,y-yOffset);ctx.lineTo(x+xOffset,y+yOffset);ctx.moveTo(x+yOffset,y-xOffset);ctx.lineTo(x-yOffset,y+xOffset);rad+=QUARTER_PI;xOffset=Math.cos(rad)*radius;yOffset=Math.sin(rad)*radius;ctx.moveTo(x-xOffset,y-yOffset);ctx.lineTo(x+xOffset,y+yOffset);ctx.moveTo(x+yOffset,y-xOffset);ctx.lineTo(x-yOffset,y+xOffset);break;case"line":xOffset=Math.cos(rad)*radius;yOffset=Math.sin(rad)*radius;ctx.moveTo(x-xOffset,y-yOffset);ctx.lineTo(x+xOffset,y+yOffset);break;case"dash":ctx.moveTo(x,y);ctx.lineTo(x+Math.cos(rad)*radius,y+Math.sin(rad)*radius);break}ctx.fill();if(options.borderWidth>0){ctx.stroke()}}function _isPointInArea(point,area){const epsilon=.5;return point.x>area.left-epsilon&&point.x<area.right+epsilon&&point.y>area.top-epsilon&&point.y<area.bottom+epsilon}function clipArea(ctx,area){ctx.save();ctx.beginPath();ctx.rect(area.left,area.top,area.right-area.left,area.bottom-area.top);ctx.clip()}function unclipArea(ctx){ctx.restore()}function _steppedLineTo(ctx,previous,target,flip,mode){if(!previous){return ctx.lineTo(target.x,target.y)}if(mode==="middle"){const midpoint=(previous.x+target.x)/2;ctx.lineTo(midpoint,previous.y);ctx.lineTo(midpoint,target.y)}else if(mode==="after"!==!!flip){ctx.lineTo(previous.x,target.y)}else{ctx.lineTo(target.x,previous.y)}ctx.lineTo(target.x,target.y)}function _bezierCurveTo(ctx,previous,target,flip){if(!previous){return ctx.lineTo(target.x,target.y)}ctx.bezierCurveTo(flip?previous.controlPointPreviousX:previous.controlPointNextX,flip?previous.controlPointPreviousY:previous.controlPointNextY,flip?target.controlPointNextX:target.controlPointPreviousX,flip?target.controlPointNextY:target.controlPointPreviousY,target.x,target.y)}function renderText(ctx,text,x,y,font,opts={}){const lines=isArray(text)?text:[text];const stroke=opts.strokeWidth>0&&opts.strokeColor!=="";let i,line;ctx.save();if(opts.translation){ctx.translate(opts.translation[0],opts.translation[1])}if(!isNullOrUndef(opts.rotation)){ctx.rotate(opts.rotation)}ctx.font=font.string;if(opts.color){ctx.fillStyle=opts.color}if(opts.textAlign){ctx.textAlign=opts.textAlign}if(opts.textBaseline){ctx.textBaseline=opts.textBaseline}for(i=0;i<lines.length;++i){line=lines[i];if(stroke){if(opts.strokeColor){ctx.strokeStyle=opts.strokeColor}if(!isNullOrUndef(opts.strokeWidth)){ctx.lineWidth=opts.strokeWidth}ctx.strokeText(line,x,y,opts.maxWidth)}ctx.fillText(line,x,y,opts.maxWidth);if(opts.strikethrough||opts.underline){const metrics=ctx.measureText(line);const left=x-metrics.actualBoundingBoxLeft;const right=x+metrics.actualBoundingBoxRight;const top=y-metrics.actualBoundingBoxAscent;const bottom=y+metrics.actualBoundingBoxDescent;const yDecoration=opts.strikethrough?(top+bottom)/2:bottom;ctx.strokeStyle=ctx.fillStyle;ctx.beginPath();ctx.lineWidth=opts.decorationWidth||2;ctx.moveTo(left,yDecoration);ctx.lineTo(right,yDecoration);ctx.stroke()}y+=font.lineHeight}ctx.restore()}const LINE_HEIGHT=new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);function toLineHeight(value,size){const matches=(""+value).match(LINE_HEIGHT);if(!matches||matches[1]==="normal"){return size*1.2}value=+matches[2];switch(matches[3]){case"px":return value;case"%":value/=100;break}return size*value}const numberOrZero=v=>+v||0;function toTRBL(value){let t,r,b,l;if(isObject(value)){t=numberOrZero(value.top);r=numberOrZero(value.right);b=numberOrZero(value.bottom);l=numberOrZero(value.left)}else{t=r=b=l=numberOrZero(value)}return{top:t,right:r,bottom:b,left:l}}function toTRBLCorners(value){let tl,tr,bl,br;if(isObject(value)){tl=numberOrZero(value.topLeft);tr=numberOrZero(value.topRight);bl=numberOrZero(value.bottomLeft);br=numberOrZero(value.bottomRight)}else{tl=tr=bl=br=numberOrZero(value)}return{topLeft:tl,topRight:tr,bottomLeft:bl,bottomRight:br}}function toPadding(value){const obj=toTRBL(value);obj.width=obj.left+obj.right;obj.height=obj.top+obj.bottom;return obj}function toFont(options,fallback){options=options||{};fallback=fallback||defaults.font;let size=valueOrDefault(options.size,fallback.size);if(typeof size==="string"){size=parseInt(size,10)}const font={family:valueOrDefault(options.family,fallback.family),lineHeight:toLineHeight(valueOrDefault(options.lineHeight,fallback.lineHeight),size),size:size,style:valueOrDefault(options.style,fallback.style),weight:valueOrDefault(options.weight,fallback.weight),string:""};font.string=toFontString(font);return font}function resolve(inputs,context,index,info){let cacheable=true;let i,ilen,value;for(i=0,ilen=inputs.length;i<ilen;++i){value=inputs[i];if(value===undefined){continue}if(context!==undefined&&typeof value==="function"){value=value(context);cacheable=false}if(index!==undefined&&isArray(value)){value=value[index%value.length];cacheable=false}if(value!==undefined){if(info&&!cacheable){info.cacheable=false}return value}}}function _lookup(table,value,cmp){cmp=cmp||(index=>table[index]<value);let hi=table.length-1;let lo=0;let mid;while(hi-lo>1){mid=lo+hi>>1;if(cmp(mid)){lo=mid}else{hi=mid}}return{lo:lo,hi:hi}}const _lookupByKey=(table,key,value)=>_lookup(table,value,index=>table[index][key]<value);const _rlookupByKey=(table,key,value)=>_lookup(table,value,index=>table[index][key]>=value);function _filterBetween(values,min,max){let start=0;let end=values.length;while(start<end&&values[start]<min){start++}while(end>start&&values[end-1]>max){end--}return start>0||end<values.length?values.slice(start,end):values}const arrayEvents=["push","pop","shift","splice","unshift"];function listenArrayEvents(array,listener){if(array._chartjs){array._chartjs.listeners.push(listener);return}Object.defineProperty(array,"_chartjs",{configurable:true,enumerable:false,value:{listeners:[listener]}});arrayEvents.forEach(key=>{const method="_onData"+_capitalize(key);const base=array[key];Object.defineProperty(array,key,{configurable:true,enumerable:false,value(...args){const res=base.apply(this,args);array._chartjs.listeners.forEach(object=>{if(typeof object[method]==="function"){object[method](...args)}});return res}})})}function unlistenArrayEvents(array,listener){const stub=array._chartjs;if(!stub){return}const listeners=stub.listeners;const index=listeners.indexOf(listener);if(index!==-1){listeners.splice(index,1)}if(listeners.length>0){return}arrayEvents.forEach(key=>{delete array[key]});delete array._chartjs}function _arrayUnique(items){const set=new Set;let i,ilen;for(i=0,ilen=items.length;i<ilen;++i){set.add(items[i])}if(set.size===ilen){return items}const result=[];set.forEach(item=>{result.push(item)});return result}function _createResolver(scopes,prefixes=[""],rootScopes=scopes,fallback){if(!defined(fallback)){fallback=_resolve("_fallback",scopes)}const cache={[Symbol.toStringTag]:"Object",_cacheable:true,_scopes:scopes,_rootScopes:rootScopes,_fallback:fallback,override:scope=>_createResolver([scope,...scopes],prefixes,rootScopes,fallback)};return new Proxy(cache,{deleteProperty(target,prop){delete target[prop];delete target._keys;delete scopes[0][prop];return true},get(target,prop){return _cached(target,prop,()=>_resolveWithPrefixes(prop,prefixes,scopes,target))},getOwnPropertyDescriptor(target,prop){return Reflect.getOwnPropertyDescriptor(target._scopes[0],prop)},getPrototypeOf(){return Reflect.getPrototypeOf(scopes[0])},has(target,prop){return getKeysFromAllScopes(target).includes(prop)},ownKeys(target){return getKeysFromAllScopes(target)},set(target,prop,value){scopes[0][prop]=value;delete target[prop];delete target._keys;return true}})}function _attachContext(proxy,context,subProxy,descriptorDefaults){const cache={_cacheable:false,_proxy:proxy,_context:context,_subProxy:subProxy,_stack:new Set,_descriptors:_descriptors(proxy,descriptorDefaults),setContext:ctx=>_attachContext(proxy,ctx,subProxy,descriptorDefaults),override:scope=>_attachContext(proxy.override(scope),context,subProxy,descriptorDefaults)};return new Proxy(cache,{deleteProperty(target,prop){delete target[prop];delete proxy[prop];return true},get(target,prop,receiver){return _cached(target,prop,()=>_resolveWithContext(target,prop,receiver))},getOwnPropertyDescriptor(target,prop){return Reflect.getOwnPropertyDescriptor(proxy,prop)},getPrototypeOf(){return Reflect.getPrototypeOf(proxy)},has(target,prop){return Reflect.has(proxy,prop)},ownKeys(){return Reflect.ownKeys(proxy)},set(target,prop,value){proxy[prop]=value;delete target[prop];return true}})}function _descriptors(proxy,defaults={scriptable:true,indexable:true}){const{_scriptable=defaults.scriptable,_indexable=defaults.indexable}=proxy;return{scriptable:_scriptable,indexable:_indexable,isScriptable:isFunction(_scriptable)?_scriptable:()=>_scriptable,isIndexable:isFunction(_indexable)?_indexable:()=>_indexable}}const readKey=(prefix,name)=>prefix?prefix+_capitalize(name):name;const needsSubResolver=(prop,value)=>isObject(value)&&prop!=="adapters";function _cached(target,prop,resolve){let value=target[prop];if(defined(value)){return value}value=resolve();if(defined(value)){target[prop]=value}return value}function _resolveWithContext(target,prop,receiver){const{_proxy,_context,_subProxy,_descriptors:descriptors}=target;let value=_proxy[prop];if(isFunction(value)&&descriptors.isScriptable(prop)){value=_resolveScriptable(prop,value,target,receiver)}if(isArray(value)&&value.length){value=_resolveArray(prop,value,target,descriptors.isIndexable)}if(needsSubResolver(prop,value)){value=_attachContext(value,_context,_subProxy&&_subProxy[prop],descriptors)}return value}function _resolveScriptable(prop,value,target,receiver){const{_proxy,_context,_subProxy,_stack}=target;if(_stack.has(prop)){throw new Error("Recursion detected: "+[..._stack].join("->")+"->"+prop)}_stack.add(prop);value=value(_context,_subProxy||receiver);_stack.delete(prop);if(isObject(value)){value=createSubResolver(_proxy._scopes,_proxy,prop,value)}return value}function _resolveArray(prop,value,target,isIndexable){const{_proxy,_context,_subProxy,_descriptors:descriptors}=target;if(defined(_context.index)&&isIndexable(prop)){value=value[_context.index%value.length]}else if(isObject(value[0])){const arr=value;const scopes=_proxy._scopes.filter(s=>s!==arr);value=[];for(const item of arr){const resolver=createSubResolver(scopes,_proxy,prop,item);value.push(_attachContext(resolver,_context,_subProxy&&_subProxy[prop],descriptors))}}return value}function resolveFallback(fallback,prop,value){return isFunction(fallback)?fallback(prop,value):fallback}const getScope$1=(key,parent)=>key===true?parent:typeof key==="string"?resolveObjectKey(parent,key):undefined;function addScopes(set,parentScopes,key,parentFallback){for(const parent of parentScopes){const scope=getScope$1(key,parent);if(scope){set.add(scope);const fallback=resolveFallback(scope._fallback,key,scope);if(defined(fallback)&&fallback!==key&&fallback!==parentFallback){return fallback}}else if(scope===false&&defined(parentFallback)&&key!==parentFallback){return null}}return false}function createSubResolver(parentScopes,resolver,prop,value){const rootScopes=resolver._rootScopes;const fallback=resolveFallback(resolver._fallback,prop,value);const allScopes=[...parentScopes,...rootScopes];const set=new Set([value]);let key=addScopesFromKey(set,allScopes,prop,fallback||prop);if(key===null){return false}if(defined(fallback)&&fallback!==prop){key=addScopesFromKey(set,allScopes,fallback,key);if(key===null){return false}}return _createResolver([...set],[""],rootScopes,fallback)}function addScopesFromKey(set,allScopes,key,fallback){while(key){key=addScopes(set,allScopes,key,fallback)}return key}function _resolveWithPrefixes(prop,prefixes,scopes,proxy){let value;for(const prefix of prefixes){value=_resolve(readKey(prefix,prop),scopes);if(defined(value)){return needsSubResolver(prop,value)?createSubResolver(scopes,proxy,prop,value):value}}}function _resolve(key,scopes){for(const scope of scopes){if(!scope){continue}const value=scope[key];if(defined(value)){return value}}}function getKeysFromAllScopes(target){let keys=target._keys;if(!keys){keys=target._keys=resolveKeysFromAllScopes(target._scopes)}return keys}function resolveKeysFromAllScopes(scopes){const set=new Set;for(const scope of scopes){for(const key of Object.keys(scope).filter(k=>!k.startsWith("_"))){set.add(key)}}return[...set]}const EPSILON=Number.EPSILON||1e-14;function splineCurve(firstPoint,middlePoint,afterPoint,t){const previous=firstPoint.skip?middlePoint:firstPoint;const current=middlePoint;const next=afterPoint.skip?middlePoint:afterPoint;const d01=Math.sqrt(Math.pow(current.x-previous.x,2)+Math.pow(current.y-previous.y,2));const d12=Math.sqrt(Math.pow(next.x-current.x,2)+Math.pow(next.y-current.y,2));let s01=d01/(d01+d12);let s12=d12/(d01+d12);s01=isNaN(s01)?0:s01;s12=isNaN(s12)?0:s12;const fa=t*s01;const fb=t*s12;return{previous:{x:current.x-fa*(next.x-previous.x),y:current.y-fa*(next.y-previous.y)},next:{x:current.x+fb*(next.x-previous.x),y:current.y+fb*(next.y-previous.y)}}}function splineCurveMonotone(points){const pointsWithTangents=(points||[]).map(point=>({model:point,deltaK:0,mK:0}));const pointsLen=pointsWithTangents.length;let i,pointBefore,pointCurrent,pointAfter;for(i=0;i<pointsLen;++i){pointCurrent=pointsWithTangents[i];if(pointCurrent.model.skip){continue}pointBefore=i>0?pointsWithTangents[i-1]:null;pointAfter=i<pointsLen-1?pointsWithTangents[i+1]:null;if(pointAfter&&!pointAfter.model.skip){const slopeDeltaX=pointAfter.model.x-pointCurrent.model.x;pointCurrent.deltaK=slopeDeltaX!==0?(pointAfter.model.y-pointCurrent.model.y)/slopeDeltaX:0}if(!pointBefore||pointBefore.model.skip){pointCurrent.mK=pointCurrent.deltaK}else if(!pointAfter||pointAfter.model.skip){pointCurrent.mK=pointBefore.deltaK}else if(sign(pointBefore.deltaK)!==sign(pointCurrent.deltaK)){pointCurrent.mK=0}else{pointCurrent.mK=(pointBefore.deltaK+pointCurrent.deltaK)/2}}let alphaK,betaK,tauK,squaredMagnitude;for(i=0;i<pointsLen-1;++i){pointCurrent=pointsWithTangents[i];pointAfter=pointsWithTangents[i+1];if(pointCurrent.model.skip||pointAfter.model.skip){continue}if(almostEquals(pointCurrent.deltaK,0,EPSILON)){pointCurrent.mK=pointAfter.mK=0;continue}alphaK=pointCurrent.mK/pointCurrent.deltaK;betaK=pointAfter.mK/pointCurrent.deltaK;squaredMagnitude=Math.pow(alphaK,2)+Math.pow(betaK,2);if(squaredMagnitude<=9){continue}tauK=3/Math.sqrt(squaredMagnitude);pointCurrent.mK=alphaK*tauK*pointCurrent.deltaK;pointAfter.mK=betaK*tauK*pointCurrent.deltaK}let deltaX;for(i=0;i<pointsLen;++i){pointCurrent=pointsWithTangents[i];if(pointCurrent.model.skip){continue}pointBefore=i>0?pointsWithTangents[i-1]:null;pointAfter=i<pointsLen-1?pointsWithTangents[i+1]:null;if(pointBefore&&!pointBefore.model.skip){deltaX=(pointCurrent.model.x-pointBefore.model.x)/3;pointCurrent.model.controlPointPreviousX=pointCurrent.model.x-deltaX;pointCurrent.model.controlPointPreviousY=pointCurrent.model.y-deltaX*pointCurrent.mK}if(pointAfter&&!pointAfter.model.skip){deltaX=(pointAfter.model.x-pointCurrent.model.x)/3;pointCurrent.model.controlPointNextX=pointCurrent.model.x+deltaX;pointCurrent.model.controlPointNextY=pointCurrent.model.y+deltaX*pointCurrent.mK}}}function capControlPoint(pt,min,max){return Math.max(Math.min(pt,max),min)}function capBezierPoints(points,area){let i,ilen,point;for(i=0,ilen=points.length;i<ilen;++i){point=points[i];if(!_isPointInArea(point,area)){continue}if(i>0&&_isPointInArea(points[i-1],area)){point.controlPointPreviousX=capControlPoint(point.controlPointPreviousX,area.left,area.right);point.controlPointPreviousY=capControlPoint(point.controlPointPreviousY,area.top,area.bottom)}if(i<points.length-1&&_isPointInArea(points[i+1],area)){point.controlPointNextX=capControlPoint(point.controlPointNextX,area.left,area.right);point.controlPointNextY=capControlPoint(point.controlPointNextY,area.top,area.bottom)}}}function _updateBezierControlPoints(points,options,area,loop){let i,ilen,point,controlPoints;if(options.spanGaps){points=points.filter(pt=>!pt.skip)}if(options.cubicInterpolationMode==="monotone"){splineCurveMonotone(points)}else{let prev=loop?points[points.length-1]:points[0];for(i=0,ilen=points.length;i<ilen;++i){point=points[i];controlPoints=splineCurve(prev,point,points[Math.min(i+1,ilen-(loop?0:1))%ilen],options.tension);point.controlPointPreviousX=controlPoints.previous.x;point.controlPointPreviousY=controlPoints.previous.y;point.controlPointNextX=controlPoints.next.x;point.controlPointNextY=controlPoints.next.y;prev=point}}if(options.capBezierPoints){capBezierPoints(points,area)}}function _getParentNode(domNode){let parent=domNode.parentNode;if(parent&&parent.toString()==="[object ShadowRoot]"){parent=parent.host}return parent}function parseMaxStyle(styleValue,node,parentProperty){let valueInPixels;if(typeof styleValue==="string"){valueInPixels=parseInt(styleValue,10);if(styleValue.indexOf("%")!==-1){valueInPixels=valueInPixels/100*node.parentNode[parentProperty]}}else{valueInPixels=styleValue}return valueInPixels}const getComputedStyle=element=>window.getComputedStyle(element,null);function getStyle(el,property){return getComputedStyle(el).getPropertyValue(property)}const positions=["top","right","bottom","left"];function getPositionedStyle(styles,style,suffix){const result={};suffix=suffix?"-"+suffix:"";for(let i=0;i<4;i++){const pos=positions[i];result[pos]=parseFloat(styles[style+"-"+pos+suffix])||0}result.width=result.left+result.right;result.height=result.top+result.bottom;return result}const useOffsetPos=(x,y,target)=>(x>0||y>0)&&(!target||!target.shadowRoot);function getCanvasPosition(evt,canvas){const e=evt.native||evt;const touches=e.touches;const source=touches&&touches.length?touches[0]:e;const{offsetX,offsetY}=source;let box=false;let x,y;if(useOffsetPos(offsetX,offsetY,e.target)){x=offsetX;y=offsetY}else{const rect=canvas.getBoundingClientRect();x=source.clientX-rect.left;y=source.clientY-rect.top;box=true}return{x:x,y:y,box:box}}function getRelativePosition(evt,chart){const{canvas,currentDevicePixelRatio}=chart;const style=getComputedStyle(canvas);const borderBox=style.boxSizing==="border-box";const paddings=getPositionedStyle(style,"padding");const borders=getPositionedStyle(style,"border","width");const{x,y,box}=getCanvasPosition(evt,canvas);const xOffset=paddings.left+(box&&borders.left);const yOffset=paddings.top+(box&&borders.top);let{width,height}=chart;if(borderBox){width-=paddings.width+borders.width;height-=paddings.height+borders.height}return{x:Math.round((x-xOffset)/width*canvas.width/currentDevicePixelRatio),y:Math.round((y-yOffset)/height*canvas.height/currentDevicePixelRatio)}}function getContainerSize(canvas,width,height){let maxWidth,maxHeight;if(width===undefined||height===undefined){const container=_getParentNode(canvas);if(!container){width=canvas.clientWidth;height=canvas.clientHeight}else{const rect=container.getBoundingClientRect();const containerStyle=getComputedStyle(container);const containerBorder=getPositionedStyle(containerStyle,"border","width");const containerPadding=getPositionedStyle(containerStyle,"padding");width=rect.width-containerPadding.width-containerBorder.width;height=rect.height-containerPadding.height-containerBorder.height;maxWidth=parseMaxStyle(containerStyle.maxWidth,container,"clientWidth");maxHeight=parseMaxStyle(containerStyle.maxHeight,container,"clientHeight")}}return{width:width,height:height,maxWidth:maxWidth||INFINITY,maxHeight:maxHeight||INFINITY}}const round1=v=>Math.round(v*10)/10;function getMaximumSize(canvas,bbWidth,bbHeight,aspectRatio){const style=getComputedStyle(canvas);const margins=getPositionedStyle(style,"margin");const maxWidth=parseMaxStyle(style.maxWidth,canvas,"clientWidth")||INFINITY;const maxHeight=parseMaxStyle(style.maxHeight,canvas,"clientHeight")||INFINITY;const containerSize=getContainerSize(canvas,bbWidth,bbHeight);let{width,height}=containerSize;if(style.boxSizing==="content-box"){const borders=getPositionedStyle(style,"border","width");const paddings=getPositionedStyle(style,"padding");width-=paddings.width+borders.width;height-=paddings.height+borders.height}width=Math.max(0,width-margins.width);height=Math.max(0,aspectRatio?Math.floor(width/aspectRatio):height-margins.height);return{width:round1(Math.min(width,maxWidth,containerSize.maxWidth)),height:round1(Math.min(height,maxHeight,containerSize.maxHeight))}}function retinaScale(chart,forceRatio,forceStyle){const pixelRatio=chart.currentDevicePixelRatio=forceRatio||1;const{canvas,width,height}=chart;canvas.height=height*pixelRatio;canvas.width=width*pixelRatio;chart.ctx.setTransform(pixelRatio,0,0,pixelRatio,0,0);if(canvas.style&&(forceStyle||!canvas.style.height&&!canvas.style.width)){canvas.style.height=height+"px";canvas.style.width=width+"px"}}const supportsEventListenerOptions=function(){let passiveSupported=false;try{const options={get passive(){passiveSupported=true;return false}};window.addEventListener("test",null,options);window.removeEventListener("test",null,options)}catch(e){}return passiveSupported}();function readUsedSize(element,property){const value=getStyle(element,property);const matches=value&&value.match(/^(\d+)(\.\d+)?px$/);return matches?+matches[1]:undefined}function _pointInLine(p1,p2,t,mode){return{x:p1.x+t*(p2.x-p1.x),y:p1.y+t*(p2.y-p1.y)}}function _steppedInterpolation(p1,p2,t,mode){return{x:p1.x+t*(p2.x-p1.x),y:mode==="middle"?t<.5?p1.y:p2.y:mode==="after"?t<1?p1.y:p2.y:t>0?p2.y:p1.y}}function _bezierInterpolation(p1,p2,t,mode){const cp1={x:p1.controlPointNextX,y:p1.controlPointNextY};const cp2={x:p2.controlPointPreviousX,y:p2.controlPointPreviousY};const a=_pointInLine(p1,cp1,t);const b=_pointInLine(cp1,cp2,t);const c=_pointInLine(cp2,p2,t);const d=_pointInLine(a,b,t);const e=_pointInLine(b,c,t);return _pointInLine(d,e,t)}const getRightToLeftAdapter=function(rectX,width){return{x(x){return rectX+rectX+width-x},setWidth(w){width=w},textAlign(align){if(align==="center"){return align}return align==="right"?"left":"right"},xPlus(x,value){return x-value},leftForLtr(x,itemWidth){return x-itemWidth}}};const getLeftToRightAdapter=function(){return{x(x){return x},setWidth(w){},textAlign(align){return align},xPlus(x,value){return x+value},leftForLtr(x,_itemWidth){return x}}};function getRtlAdapter(rtl,rectX,width){return rtl?getRightToLeftAdapter(rectX,width):getLeftToRightAdapter()}function overrideTextDirection(ctx,direction){let style,original;if(direction==="ltr"||direction==="rtl"){style=ctx.canvas.style;original=[style.getPropertyValue("direction"),style.getPropertyPriority("direction")];style.setProperty("direction",direction,"important");ctx.prevTextDirection=original}}function restoreTextDirection(ctx,original){if(original!==undefined){delete ctx.prevTextDirection;ctx.canvas.style.setProperty("direction",original[0],original[1])}}function propertyFn(property){if(property==="angle"){return{between:_angleBetween,compare:_angleDiff,normalize:_normalizeAngle}}return{between:(n,s,e)=>n>=s&&n<=e,compare:(a,b)=>a-b,normalize:x=>x}}function makeSubSegment(start,end,loop,count){return{start:start%count,end:end%count,loop:loop&&(end-start+1)%count===0}}function getSegment(segment,points,bounds){const{property,start:startBound,end:endBound}=bounds;const{between,normalize}=propertyFn(property);const count=points.length;let{start,end,loop}=segment;let i,ilen;if(loop){start+=count;end+=count;for(i=0,ilen=count;i<ilen;++i){if(!between(normalize(points[start%count][property]),startBound,endBound)){break}start--;end--}start%=count;end%=count}if(end<start){end+=count}return{start:start,end:end,loop:loop}}function _boundSegment(segment,points,bounds){if(!bounds){return[segment]}const{property,start:startBound,end:endBound}=bounds;const count=points.length;const{compare,between,normalize}=propertyFn(property);const{start,end,loop}=getSegment(segment,points,bounds);const result=[];let inside=false;let subStart=null;let value,point,prevValue;const startIsBefore=()=>between(startBound,prevValue,value)&&compare(startBound,prevValue)!==0;const endIsBefore=()=>compare(endBound,value)===0||between(endBound,prevValue,value);const shouldStart=()=>inside||startIsBefore();const shouldStop=()=>!inside||endIsBefore();for(let i=start,prev=start;i<=end;++i){point=points[i%count];if(point.skip){continue}value=normalize(point[property]);inside=between(value,startBound,endBound);if(subStart===null&&shouldStart()){subStart=compare(value,startBound)===0?i:prev}if(subStart!==null&&shouldStop()){result.push(makeSubSegment(subStart,i,loop,count));subStart=null}prev=i;prevValue=value}if(subStart!==null){result.push(makeSubSegment(subStart,end,loop,count))}return result}function _boundSegments(line,bounds){const result=[];const segments=line.segments;for(let i=0;i<segments.length;i++){const sub=_boundSegment(segments[i],line.points,bounds);if(sub.length){result.push(...sub)}}return result}function findStartAndEnd(points,count,loop,spanGaps){let start=0;let end=count-1;if(loop&&!spanGaps){while(start<count&&!points[start].skip){start++}}while(start<count&&points[start].skip){start++}start%=count;if(loop){end+=start}while(end>start&&points[end%count].skip){end--}end%=count;return{start:start,end:end}}function solidSegments(points,start,max,loop){const count=points.length;const result=[];let last=start;let prev=points[start];let end;for(end=start+1;end<=max;++end){const cur=points[end%count];if(cur.skip||cur.stop){if(!prev.skip){loop=false;result.push({start:start%count,end:(end-1)%count,loop:loop});start=last=cur.stop?end:null}}else{last=end;if(prev.skip){start=end}}prev=cur}if(last!==null){result.push({start:start%count,end:last%count,loop:loop})}return result}function _computeSegments(line){const points=line.points;const spanGaps=line.options.spanGaps;const count=points.length;if(!count){return[]}const loop=!!line._loop;const{start,end}=findStartAndEnd(points,count,loop,spanGaps);if(spanGaps===true){return[{start:start,end:end,loop:loop}]}const max=end<start?end+count:end;const completeLoop=!!line._fullLoop&&start===0&&end===count-1;return solidSegments(points,start,max,completeLoop)}export{mergeIf as $,_rlookupByKey as A,toPadding as B,each as C,getMaximumSize as D,_getParentNode as E,readUsedSize as F,throttled as G,HALF_PI as H,supportsEventListenerOptions as I,log10 as J,finiteOrDefault as K,callback as L,toDegrees as M,_measureText as N,_int16Range as O,PI as P,_alignPixel as Q,renderText as R,toFont as S,TAU as T,_factorize as U,_capitalize as V,isFunction as W,_attachContext as X,_createResolver as Y,_descriptors as Z,_arrayUnique as _,resolve as a,uid as a0,debounce as a1,retinaScale as a2,clearCanvas as a3,_elementsEqual as a4,getAngleFromPoint as a5,_updateBezierControlPoints as a6,_computeSegments as a7,_boundSegments as a8,_steppedInterpolation as a9,clone as aA,_merger as aB,merge as aC,_mergerIf as aD,_deprecated as aE,splineCurve as aF,splineCurveMonotone as aG,getStyle as aH,toLineHeight as aI,PITAU as aJ,INFINITY as aK,RAD_PER_DEG as aL,QUARTER_PI as aM,TWO_THIRDS_PI as aN,_angleDiff as aO,_bezierInterpolation as aa,_pointInLine as ab,_steppedLineTo as ac,_bezierCurveTo as ad,drawPoint as ae,toTRBL as af,toTRBLCorners as ag,_boundSegment as ah,_normalizeAngle as ai,getRtlAdapter as aj,_alignStartEnd as ak,overrideTextDirection as al,restoreTextDirection as am,_toLeftRightCenter as an,noop as ao,distanceBetweenPoints as ap,toFontString as aq,_setMinAndMaxByKey as ar,_decimalPlaces as as,almostEquals as at,almostWhole as au,_longestText as av,_filterBetween as aw,_lookup as ax,getHoverColor as ay,fontString as az,isArray as b,color as c,defaults as d,effects as e,resolveObjectKey as f,isNumberFinite as g,defined as h,isObject as i,isNullOrUndef as j,clipArea as k,listenArrayEvents as l,unclipArea as m,toPercentage as n,toPixels as o,_angleBetween as p,isNumber as q,requestAnimFrame as r,sign as s,toRadians as t,unlistenArrayEvents as u,valueOrDefault as v,_limitValue as w,_lookupByKey as x,getRelativePosition as y,_isPointInArea as z};